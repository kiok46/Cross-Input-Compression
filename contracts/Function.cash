pragma cashscript 0.11.4;

// P2RSH, Pay to Redeem Script Hash
// contract P2RSH(bytes32 redeemScriptHash) {

// P2RS, Pay to Redeem Script
contract P2RS(bytes redeemScript) {

  function execute() {
    require(tx.version == 2);

    // LOOPED: This index will be updated using loops upgrade, it will go through all the inputs within the transaction
    // int inputs = tx.inputs.length;
    // for(int idx = 0; idx < inputs; idx++) {
    // Since loops are not implemented in the Bitcoin Cash VM yet, this is just a proof of concept
    int idx = 1;

    // Ensure it's a P2SH input
    bytes lockingBytecode = tx.inputs[idx].lockingBytecode;
    require(lockingBytecode.length == 35);
    require(lockingBytecode.split(2)[0] == 0xaa20, "P2SH32 locking bytecode must start with OP_SHA256 <Push 32-bytes> (0xaa20)");
    require(lockingBytecode.split(34)[1] == 0x87, "P2SH32 locking bytecode must end with OP_EQUAL (0x87)");

    // Extract the redeem script
    // 84 is the expected length of the unlocking bytecode based on how the main contract is constructed
    // The expected unlocking byytecode is

    // OP_1 OP_PUSHDATA1 0x50 0x23 <35-bytes-lockingbytecode> 0x20 <20-bytes-pkh> <redeem script>
    bytes redeemScriptFromInput = tx.inputs[idx].unlockingBytecode.split(60)[1];

    if(redeemScriptFromInput == redeemScript) {
      // Execute the function logic

      // Trade logic
      require(tx.outputs[idx].tokenCategory == tx.inputs[idx].tokenCategory);
      require(tx.outputs[idx].lockingBytecode == tx.inputs[idx].lockingBytecode);
    
      int inputSat = tx.inputs[idx].value;
      int outputSat = tx.outputs[idx].value;
      int fee = (abs(outputSat - inputSat) * 3) / 1000;

      int outputValueAfterFee = outputSat - fee;

      int inputTokenValue = tx.inputs[idx].tokenAmount;
      int outputTokenValue = tx.outputs[idx].tokenAmount;

      int effectiveK = outputValueAfterFee * outputTokenValue;
      int targetK = inputSat * inputTokenValue;

      require(effectiveK >= targetK);
    }
  }
}